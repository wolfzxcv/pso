<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PSO</title>
    <script>
      // inertia weight for SPSO
      const W = 0.05;

      // inertia weight for MPSO
      const W_MPSO = W * 5;
      // factor for the decreasing exponential, use for W_MPSO
      let factor = 0;

      // cognitive coefficient
      const c1 = 0.5;
      // social coefficient
      const c2 = 2.5;

      // search range
      const min = -100;
      const max = 100;

      // iteration times
      const iterations = 25;
      // how many individual in a particle
      const particle = 30;

      // current Global best value
      let currentGBest;

      // current global best position for x
      let currentGBestPositionX;

      // current global best position for y
      let currentGBestPositionY;

      // store gBest values to calculate mean value
      let gBestValues = [];

      // record the result of current iteration
      let currentResult = [];

      for (let iteration = 0; iteration < iterations; iteration++) {
        const whichTime = iteration + 1;
        console.log(`-----Iteration ${whichTime}-----`);
        if (iteration === 0) {
          // 1. initial 1st round data
          currentResult = Array(particle)
            .fill()
            .map((each) => {
              const positionX = randomValue(min, max);
              const positionY = randomValue(min, max);
              const velocityX = randomValue(min, max);
              const velocityY = randomValue(min, max);
              const fucVal = benchmark(positionX, positionY);
              return {
                positionX,
                positionY,
                velocityX,
                velocityY,
                fucVal,
                pBest: fucVal,
                pBestPositionX: positionX,
                pBestPositionY: positionY
              };
            });

          organizeResult(currentResult);
        } else {
          /*
            MPSO
            More than SPSO setting of W at first, decreasing exponentially.

            If the algorithm is trapped in local minima (current particle best is not smaller than current global best), we modify W to make it even smaller
            */
          // update factor for W_MPSO
          // start to decrease factor at the 3rd iteration
          if (whichTime > 2) {
            factor = factor + 1;
          }

          const currentW_MPSO = getNewW_MPSO();

          // 2. update current result
          // copy result from the last iteration
          const lastIteration = [...currentResult];

          currentResult = lastIteration.map((each) => {
            const r1X = randomValue(0, 1);
            const r2X = randomValue(0, 1);
            const r1Y = randomValue(0, 1);
            const r2Y = randomValue(0, 1);
            // Vit+1 = wVit + c1r1(Pit - Xit)+c2r2(Gt-xit)
            // SPSO
            const wVitX = W * each.velocityX;
            const wVitY = W * each.velocityY;

            // MPSO
            // const wVitX = currentW_MPSO * each.velocityX;
            // const wVitY = currentW_MPSO * each.velocityY;

            const velocityX =
              wVitX +
              c1 * r1X * (each.pBestPositionX - each.positionX) +
              c2 * r2X * (currentGBestPositionX - each.positionX);

            const velocityY =
              wVitY +
              c1 * r1Y * (each.pBestPositionY - each.positionY) +
              c2 * r2Y * (currentGBestPositionY - each.positionY);
            // Xit+1 = Xit +Vit+1
            const positionX = each.positionX + velocityX;
            const positionY = each.positionY + velocityY;

            const fucVal = benchmark(positionX, positionY);

            const currentIsBetter = fucVal < each.pBest;

            const pBest = currentIsBetter ? fucVal : each.pBest;
            const pBestPositionX = currentIsBetter
              ? positionX
              : each.pBestPositionX;
            const pBestPositionY = currentIsBetter
              ? positionY
              : each.pBestPositionY;

            return {
              positionX,
              positionY,
              velocityX,
              velocityY,
              fucVal,
              pBest,
              pBestPositionX,
              pBestPositionY
            };
          });
          organizeResult(currentResult);
        }
      }

      calculateStdDev(gBestValues);

      // generate random value within the giving range
      function randomValue(min, max) {
        return Math.random() * (max - min) + min;
      }

      // benchmark functions
      function benchmark(x, y) {
        return x ** 2 + y ** 2;
      }

      //  organize result
      function organizeResult(data) {
        // find and record the current global best value
        const sortData = data.toSorted((a, b) => a.pBest - b.pBest);

        // toFixed will also convert the number to string, so change it back to number
        const sortDataFucValBest = Number(sortData[0].fucVal.toFixed(2));
        if (
          currentGBest === undefined ||
          (currentGBest && sortDataFucValBest < currentGBest)
        ) {
          currentGBestPositionX = sortData[0].positionX;
          currentGBestPositionY = sortData[0].positionY;

          currentGBest = sortDataFucValBest;
        } else if (sortDataFucValBest > currentGBest) {
          // means trap in the local minima, so we make w smaller
          factor = factor + 1;
          console.log('trap in the local minima');
        }

        // print current result
        console.log('Current result: ', currentResult);
        // print current global best value

        console.log('Current gBest: ', currentGBest);
        // store the current gBest
        gBestValues.push(currentGBest);
      }

      function calculateMean(arr) {
        const sum = arr.reduce(
          (accumulator, currentValue) => accumulator + currentValue,
          0
        );
        const n = arr.length;

        const mean = sum / n;

        return mean;
      }

      function calculateStdDev(arr) {
        const mean = calculateMean(arr);

        const n = arr.length;

        const all = arr
          .map((each) => {
            return (each - mean) ** 2;
          })
          .reduce((acc, cur) => acc + cur, 0);

        const stdDev = Math.sqrt(all / n);

        console.log('mean: ', mean, 'stdDev: ', stdDev);

        return stdDev;
      }

      function getNewW_MPSO() {
        // start from the setting of W_MPSO, and then divide the value by 2 every time when factor is incremented by 1.
        const newValue = W_MPSO / Math.pow(2, factor);
        return newValue;
      }
    </script>
  </head>
  <body>
    <script></script>
  </body>
</html>
